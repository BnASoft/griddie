{"version":3,"sources":["src/griddie.utils.js","src/toolbox/src/toolbox.client.js","src/toolbox/src/toolbox.timers.js","src/toolbox/src/toolbox.utils.js","src/toolbox/src/toolbox.viewport.js","src/toolbox/src/toolbox.events.js","src/griddie.js"],"names":["global","factory","exports","module","define","amd","Griddie","this","isPromise","object","then","vendorsPrefixes","navigator","userAgent","toLowerCase","MutationObserver","i","length","window","getObserverId","el","document","createElement","transEndEventNames","WebkitTransition","MozTransition","OTransition","msTransition","transition","name","undefined","style","parent","prefix","classList","join","id","disconnectObserver","mode","observerId","disconnect","clearElementTimer","element","autoDisconnectObserver","parentElement","attachTimeout","callback","time","e","removedNodes","some","observe","childList","setElementTimer","detachTimeout","stringContains","heystack","needle","String","prototype","includes","indexOf","Viewport","[object Object]","_window","_html","documentElement","_body","body","_frame1","_frame2","_prefix1","_prefix2","_offsetWidth","_offsetHeight","_width","_height","_scrollTop","_scrollLeft","_lock","calcAll","offsetWidth","offsetHeight","width","height","scrollTop","scrollLeft","all","calcOffsetWidth","calcOffsetHeight","calcWidth","calcHeight","calcScrollTop","calcScrollLeft","lock","bool","top","left","scrollBarWidth","scrollBarHeight","position","Math","abs","parseFloat","scroll","behavior","privateEventsStorage","CustomEvent","_polyfill","event","params","bubbles","cancelable","detail","evt","createEvent","initCustomEvent","Event","detachEventListener","events","startsWith","substr","stringStartsWith","key","eventNameWithNamespace","replace","type","split","removeEventListener","handler","attachEventListener","once","count","_handler","call","addEventListener","options","_element","_items","children","_options","_viewport","instance","layout","scaleXY","opacityTiming","transformTiming","masonry","transformTimingCSS","opacityTimingCSS","layoutChanges","Promise","resolve","reject","clearGridStyles","clearItemsStyles","storeGridData","storeItemsData","applyGridStyles","applyItemsStyles","requestAnimationFrame","transformTransition","widthHeightTransition","filter","item","display","forEach","changes","matched","x","matches","unmatched","hiddenMatched","makeRoomBeforeFade","prepareFade","fade","opacity","clearFade","animate","onFadeEnd","clearTimeout","_filterTimeout","setTimeout","gridRowEnd","rect","computed","getComputedStyle","getPropertyValue","gridTemplateColumns","rowHeight","gridAutoRows","parseInt","gridColumnGap","rowGap","gridRowGap","rowSpan","ceil","getBoundingClientRect","transform","margin","transformOrigin","gridRect","marginTop","marginLeft","itemRect","scaleX","scaleY"],"mappings":"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","sourcesContent":["export const isPromise = object => !!object && (typeof object === 'object' || typeof object === 'function') && typeof object.then === 'function';\r\n","let maxAnisotropy = null;\r\nconst getMaxAnisotropy = () => {\r\n    if (maxAnisotropy !== null) {\r\n        return maxAnisotropy;\r\n    }\r\n\r\n    const canvas = document.createElement('canvas');\r\n    let gl = null;\r\n    try {\r\n        gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\r\n    } catch (e) {}\r\n\r\n    if (null !== gl && 'getExtension' in gl) {\r\n        const ext =\r\n            gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');\r\n\r\n        if (ext && 'MAX_TEXTURE_MAX_ANISOTROPY_EXT' in ext) {\r\n            maxAnisotropy = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\r\n        }\r\n    }\r\n\r\n    return maxAnisotropy;\r\n};\r\n\r\nexport const hasModernHardware = () => getMaxAnisotropy() >= 4;\r\n\r\n// iOS safari does\r\nlet transformBreaksFixedSystem = false;\r\nexport const doesTransformBreakFixed = () => {\r\n    if (transformBreaksFixedSystem !== null) {\r\n        return transformBreaksFixedSystem;\r\n    }\r\n\r\n    const a = document.createElement('div');\r\n    const b = document.createElement('div');\r\n\r\n    a.style.position = 'absolute';\r\n    a.style.top = '0px';\r\n    a.style.left = '-9999px';\r\n    a.style.width = '1px';\r\n    a.style.height = '1px';\r\n    a.style.visibility = 'hidden';\r\n    a.style.transform = 'translateZ(0)';\r\n\r\n    b.style.position = 'fixed';\r\n    b.style.top = '0px';\r\n    b.style.left = '0px';\r\n    b.style.width = '100%';\r\n    b.style.height = '100%';\r\n\r\n    document.body.append(a);\r\n    a.append(b);\r\n\r\n    transformBreaksFixedSystem = b.getBoundingClientRect().top < 0;\r\n\r\n    a.remove();\r\n\r\n    return transformBreaksFixedSystem;\r\n};\r\n\r\n// firefox does\r\nlet fixedBreakStickySystem = false;\r\nexport const doesFixedBreakSticky = () => {\r\n    if (fixedBreakStickySystem !== null) {\r\n        return fixedBreakStickySystem;\r\n    }\r\n\r\n    const a = document.createElement('div');\r\n    const b = document.createElement('div');\r\n    const c = document.createElement('div');\r\n\r\n    a.style.position = 'fixed';\r\n    a.style.top = '0';\r\n    a.style.left = '-9999px';\r\n    a.style.width = '1px';\r\n    a.style.height = '1px';\r\n\r\n    b.style.position = 'relative';\r\n    b.style.top = '-9800px';\r\n    b.style.left = '0px';\r\n    b.style.width = '100%';\r\n    b.style.height = '9999px';\r\n\r\n    c.style.position = 'sticky';\r\n    c.style.position = '-webkit-sticky';\r\n    c.style.top = '0px';\r\n    c.style.left = '0px';\r\n    c.style.width = '100%';\r\n    c.style.height = '100px';\r\n\r\n    document.body.append(a);\r\n    a.append(b);\r\n    b.append(c);\r\n\r\n    fixedBreakStickySystem = c.getBoundingClientRect().top < 0;\r\n\r\n    a.remove();\r\n\r\n    return fixedBreakStickySystem;\r\n};\r\n\r\nconst userAgent = navigator.userAgent.toLowerCase();\r\nconst iOSDevices = ['iphone', 'ipad', 'ipod'];\r\n\r\nlet os = null;\r\nexport const getOS = () => {\r\n    if (os !== null) {\r\n        return os;\r\n    }\r\n\r\n    if (userAgent.indexOf('win') !== -1) {\r\n        os = 'windows';\r\n        return os;\r\n    }\r\n\r\n    if (userAgent.indexOf('mac') !== -1) {\r\n        os = 'mac';\r\n        return os;\r\n    }\r\n\r\n    if (userAgent.indexOf('x11') !== -1) {\r\n        os = 'unix';\r\n        return os;\r\n    }\r\n\r\n    if (userAgent.indexOf('linux') !== -1) {\r\n        os = 'linux';\r\n        return os;\r\n    }\r\n\r\n    if (getBrowser() !== 'edge' && userAgent.indexOf('android') !== -1) {\r\n        os = 'android';\r\n        return os;\r\n    }\r\n\r\n    if (iOSDevices.indexOf(getDevice()) !== -1 || userAgent.indexOf('crios') !== -1) {\r\n        os = 'ios';\r\n        return os;\r\n    }\r\n\r\n    os = 'unknown';\r\n\r\n    return os;\r\n};\r\n\r\nlet device = null;\r\nexport const getDevice = () => {\r\n    if (device !== null) {\r\n        return device;\r\n    }\r\n\r\n    const iosDeviceMatch = userAgent.match(new RegExp(iOSDevices.join('|')));\r\n\r\n    if (null !== iosDeviceMatch && !('MSStream' in window)) {\r\n        device = iosDeviceMatch[0];\r\n        return device;\r\n    }\r\n\r\n    if (/android|webos|blackberry|iemobile|opera mini|mobile|mobile|crios/i.test(userAgent)) {\r\n        device = 'mobile';\r\n        return device;\r\n    }\r\n\r\n    os = os || getOS();\r\n    if (os === 'windows' || os === 'mac' || os === 'unix' || os === 'linux') {\r\n        device = 'desktop';\r\n        return device;\r\n    }\r\n\r\n    device = 'unknown';\r\n\r\n    return device;\r\n};\r\n\r\nlet browser = null;\r\nexport const getBrowser = () => {\r\n    if (browser !== null) {\r\n        return browser;\r\n    }\r\n\r\n    if (/edge\\/\\d/.test(userAgent)) {\r\n        browser = 'edge';\r\n        return browser;\r\n    }\r\n\r\n    if (userAgent.indexOf('chrome') !== -1 || userAgent.indexOf('crios') !== -1) {\r\n        browser = 'chrome';\r\n        return browser;\r\n    }\r\n\r\n    if (userAgent.indexOf('firefox') !== -1) {\r\n        browser = 'firefox';\r\n        return browser;\r\n    }\r\n\r\n    if (getDevice() !== 'android') {\r\n        browser = 'safari';\r\n        return browser;\r\n    }\r\n\r\n    if (userAgent.indexOf('msie ') !== -1 || userAgent.indexOf('trident/') !== -1) {\r\n        browser = 'msie';\r\n        return browser;\r\n    }\r\n\r\n    browser = 'unknown';\r\n    return browser;\r\n};\r\n\r\nconst vendorsPrefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];\r\n\r\nexport const MutationObserver = (() => {\r\n    for (let i = 0; i < vendorsPrefixes.length; i++) {\r\n        if (vendorsPrefixes[i] + 'MutationObserver' in window) {\r\n            return window[vendorsPrefixes[i] + 'MutationObserver'];\r\n        }\r\n    }\r\n\r\n    return false;\r\n})();\r\n\r\nexport const transitionEndEventName = (() => {\r\n    const el = document.createElement('div');\r\n\r\n    const transEndEventNames = {\r\n        WebkitTransition: 'webkitTransitionEnd',\r\n        MozTransition: 'transitionend',\r\n        OTransition: 'oTransitionEnd otransitionend',\r\n        msTransition: 'MSTransitionEnd',\r\n        transition: 'transitionend'\r\n    };\r\n\r\n    for (let name in transEndEventNames) {\r\n        if (el.style[name] !== undefined) {\r\n            return transEndEventNames[name];\r\n        }\r\n    }\r\n\r\n    return false;\r\n})();\r\n\r\nexport const intersectionObserverSupported = 'IntersectionObserver' in window;\r\nexport const pictureElementSupported = 'HTMLPictureElement' in window;\r\n","import { MutationObserver } from './toolbox.client.js';\r\n\r\nconst getObserverId = (parent, prefix) => prefix + [...parent.classList].join('') + parent.id + 'Observer';\r\n\r\nconst disconnectObserver = (parent, mode, id) => {\r\n    const observerId = getObserverId(parent, id + mode);\r\n    if (parent[observerId]) {\r\n        parent[observerId].disconnect();\r\n        delete parent[observerId];\r\n    }\r\n};\r\n\r\nconst setElementTimer = (element, mode, callback, time, id) => {\r\n    clearElementTimer(element, mode, id);\r\n    element[id] = window['set' + mode](callback, time);\r\n\r\n    const parent = element.parentElement;\r\n    const observerId = getObserverId(parent, id + mode);\r\n    parent[observerId] = new MutationObserver(e => {\r\n        if ([...e[0].removedNodes].some(el => el === element)) {\r\n            clearElementTimer(element, mode, id);\r\n            disconnectObserver(parent, mode, id);\r\n        }\r\n    });\r\n    parent[observerId].observe(parent, { childList: true });\r\n};\r\n\r\nconst clearElementTimer = (element, mode, id, autoDisconnectObserver = false) => {\r\n    window['clear' + mode](element[id]);\r\n    delete element[id];\r\n\r\n    const parent = element.parentElement;\r\n    if (autoDisconnectObserver) {\r\n        disconnectObserver(parent, mode, id);\r\n    }\r\n};\r\n\r\nexport const attachTimeout = (element, callback = () => {}, time = 0, id = 'niteTimeout') => setElementTimer(element, 'Timeout', callback, time, id);\r\nexport const detachTimeout = (element, id = 'niteTimeout') => clearElementTimer(element, 'Timeout', id, true);\r\nexport const attachInterval = (element, callback = () => {}, time = 0, id = 'niteInterval') => setElementTimer(element, 'Interval', callback, time, id);\r\nexport const detachInterval = (element, id = 'niteInterval') => clearElementTimer(element, 'Interval', id, true);\r\n","/**\r\n * @param {string} prop\r\n * @param {string} value\r\n * @returns {boolean}\r\n */\r\nexport const isCSSPropertyValueSupported = (tag, prop, value) => {\r\n    if ('CSS' in window && 'supports' in CSS) {\r\n        return CSS.supports(prop, value);\r\n    }\r\n\r\n    const d = document.createElement(tag);\r\n    d.style[prop] = value;\r\n\r\n    return d.style[prop] === value;\r\n};\r\n\r\n/**\r\n * @param {(string|number)} num\r\n * @returns {number}\r\n */\r\nexport const roundDecimals = (num, decimals = 4) => {\r\n    return parseFloat(num.toFixed(decimals));\r\n};\r\n\r\n/**\r\n * @returns {string}\r\n */\r\nexport const generateInstanceID = () => {\r\n    return Math.floor(Math.random() * (9999 - 1000)) + 1000;\r\n};\r\n\r\n/**\r\n * @param {string} heystack\r\n * @param {string} needle\r\n * @returns {boolean}\r\n */\r\nexport const stringContains = (heystack, needle) => {\r\n    return String.prototype.includes ? heystack.includes(needle) : heystack.indexOf(needle, 0) !== -1;\r\n};\r\n\r\n/**\r\n * @param {string} heystack\r\n * @param {string} needle\r\n * @returns {boolean}\r\n */\r\nexport const stringStartsWith = (heystack, needle) => {\r\n    return String.prototype.startsWith ? heystack.startsWith(needle) : heystack.substr(0, needle.length) === needle;\r\n};\r\n\r\n/**\r\n * @param {Array} heystack\r\n * @param {Function} filter\r\n * @returns {number}\r\n */\r\nexport const arrayFindIndex = (heystack, filter) => {\r\n    return Array.prototype.findIndex\r\n        ? heystack.findIndex(filter)\r\n        : (() => {\r\n              let length = heystack.length,\r\n                  index = -1;\r\n              while (++index < length) {\r\n                  if (filter(heystack[index], index, heystack)) {\r\n                      return index;\r\n                  }\r\n              }\r\n              return -1;\r\n          })();\r\n};\r\n\r\n/**\r\n * @param {string} string\r\n * @returns {string}\r\n */\r\nexport const hyphensToCamelCase = string => {\r\n    return string.replace(/-([a-z])/g, g => g[1].toUpperCase());\r\n};\r\n\r\n/**\r\n * @param {string} string\r\n * @returns {string}\r\n */\r\nexport const capitalize = string => {\r\n    return string.charAt(0).toUpperCase() + string.slice(1);\r\n};\r\n\r\n/**\r\n * @param {NodeList} nodelist\r\n * @returns {Array}\r\n */\r\nexport const nodelistToArray = nodelist => {\r\n    return [...nodelist];\r\n};\r\n\r\n/**\r\n * @param {String|number} needle\r\n * @param {Array} heystack\r\n * @returns {boolean}\r\n */\r\nexport const isInArray = (needle, heystack) => {\r\n    return heystack.indexOf(needle) > -1;\r\n};\r\n","import { roundDecimals } from './toolbox.utils.js';\r\n\r\n/**\r\n *\r\n * @param {Number} percentage\r\n * @returns {Number}\r\n */\r\nconst roundPercentage = percentage => {\r\n    if (percentage > 100) {\r\n        percentage = 100;\r\n    } else if (percentage < 0) {\r\n        percentage = 0;\r\n    } else {\r\n        percentage = roundDecimals(percentage, 4);\r\n    }\r\n\r\n    return percentage;\r\n};\r\n\r\nconst isIntersectionObserverSupported = 'IntersectionObserver' in window;\r\n\r\nconst intersectionObserverThreshold = (factor => {\r\n    let threshold = [];\r\n    if (isIntersectionObserverSupported) {\r\n        for (let i = 0; i <= 100 / factor; i++) {\r\n            threshold.push((i * factor) / 100);\r\n        }\r\n    }\r\n    return threshold;\r\n})(2);\r\n\r\n/**\r\n *\r\n */\r\nexport class Viewport {\r\n    constructor() {\r\n        this._window = window;\r\n        this._html = document.documentElement;\r\n        this._body = document.body;\r\n\r\n        this._frame1 = this._window;\r\n        this._frame2 = this._html || this._body;\r\n        this._prefix1 = 'inner';\r\n        this._prefix2 = 'offset';\r\n        if (!this._prefix1 + 'Width' in this._frame1) {\r\n            this._prefix1 = 'client';\r\n            this._frame1 = this._frame2;\r\n        }\r\n\r\n        this._offsetWidth = 0;\r\n        this._offsetHeight = 0;\r\n        this._width = 0;\r\n        this._height = 0;\r\n        this._scrollTop = 0;\r\n        this._scrollLeft = 0;\r\n\r\n        this._lock = false;\r\n\r\n        this.calcAll();\r\n    }\r\n\r\n    get offsetWidth() {\r\n        return this._offsetWidth;\r\n    }\r\n    get offsetHeight() {\r\n        return this._offsetHeight;\r\n    }\r\n    get width() {\r\n        return this._width;\r\n    }\r\n    get height() {\r\n        return this._height;\r\n    }\r\n    get scrollTop() {\r\n        return this._scrollTop;\r\n    }\r\n    get scrollLeft() {\r\n        return this._scrollLeft;\r\n    }\r\n    get all() {\r\n        return {\r\n            offsetWidth: this.offsetWidth,\r\n            offsetHeight: this.offsetHeight,\r\n            width: this.width,\r\n            height: this.height,\r\n            scrollTop: this.scrollTop,\r\n            scrollLeft: this.scrollLeft\r\n        };\r\n    }\r\n\r\n    calcOffsetWidth() {\r\n        this._offsetWidth = this._body[this._prefix2 + 'Width'];\r\n        return this.offsetWidth;\r\n    }\r\n    calcOffsetHeight() {\r\n        this._offsetHeight = this._body[this._prefix2 + 'Height'];\r\n        return this.offsetHeight;\r\n    }\r\n    calcWidth() {\r\n        this._width = this._frame1[this._prefix1 + 'Width'];\r\n        return this.width;\r\n    }\r\n    calcHeight() {\r\n        this._height = this._frame1[this._prefix1 + 'Height'];\r\n        return this.height;\r\n    }\r\n    calcScrollTop() {\r\n        this._scrollTop = this._frame2.scrollTop || 0;\r\n        return this.scrollTop;\r\n    }\r\n    calcScrollLeft() {\r\n        this._scrollLeft = this._frame2.scrollLeft || 0;\r\n        return this.scrollLeft;\r\n    }\r\n    calcAll() {\r\n        this.calcOffsetWidth();\r\n        this.calcOffsetHeight();\r\n        this.calcWidth();\r\n        this.calcHeight();\r\n        this.calcScrollTop();\r\n        this.calcScrollLeft();\r\n        return this.all;\r\n    }\r\n\r\n    get lock() {\r\n        return this._lock;\r\n    }\r\n\r\n    set lock(bool) {\r\n        this._lock = bool;\r\n\r\n        if (this._lock) {\r\n            this._body.style.top = -this.calcScrollTop() + 'px';\r\n            this._body.style.left = -this.calcScrollLeft() + 'px';\r\n\r\n            let scrollBarWidth = this.calcOffsetWidth();\r\n            let scrollBarHeight = this.calcOffsetHeight();\r\n\r\n            this._html.style.top = '0px';\r\n            this._html.style.left = '0px';\r\n            this._html.style.position = 'fixed';\r\n            this._body.style.position = 'fixed';\r\n            this._html.style.width = '100%';\r\n            this._body.style.width = '100%';\r\n\r\n            let offsetWidth = this.calcOffsetWidth();\r\n            let offsetHeight = this.calcOffsetHeight();\r\n            scrollBarWidth = offsetWidth - scrollBarWidth;\r\n            scrollBarHeight = offsetHeight - scrollBarHeight;\r\n\r\n            this._body.style.width = offsetWidth - scrollBarWidth + 'px';\r\n            this._body.style.height = offsetHeight - scrollBarHeight + 'px';\r\n        } else {\r\n            let scrollTop = Math.abs(parseFloat(this._body.style.top));\r\n            let scrollLeft = Math.abs(parseFloat(this._body.style.left));\r\n\r\n            this._html.style.position = '';\r\n            this._html.style.top = '';\r\n            this._html.style.left = '';\r\n            this._html.style.width = '';\r\n            this._body.style.position = '';\r\n            this._body.style.top = '';\r\n            this._body.style.left = '';\r\n            this._body.style.width = '';\r\n\r\n            this._window.scroll({\r\n                top: scrollTop,\r\n                left: scrollLeft,\r\n                behavior: 'instant'\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @param {DOMRect} bounds\r\n * @returns {Object}\r\n */\r\nexport const getBoundsViewportIntersection = bounds => {\r\n    const viewport = new Viewport();\r\n\r\n    if (bounds.right < 0 || bounds.bottom < 0 || bounds.left > viewport.width || bounds.top > viewport.height) {\r\n        return {\r\n            x: 0,\r\n            y: 0,\r\n            ratio: 0\r\n        };\r\n    }\r\n\r\n    const offTop = bounds.top < 0;\r\n    const offBottom = bounds.top + bounds.height > viewport.height;\r\n    const offLeft = bounds.left < 0;\r\n    const offRight = bounds.left + bounds.width > viewport.width;\r\n\r\n    if (!offTop && !offBottom && !offLeft && !offRight) {\r\n        return {\r\n            x: 100,\r\n            y: 100,\r\n            ratio: 100\r\n        };\r\n    }\r\n\r\n    let offY = 0;\r\n    let offX = 0;\r\n\r\n    if (offTop) {\r\n        offY = Math.abs(bounds.top);\r\n    }\r\n\r\n    if (offBottom) {\r\n        offY = bounds.top + bounds.height - viewport.height;\r\n    }\r\n\r\n    if (offLeft) {\r\n        offX = Math.abs(bounds.left);\r\n    }\r\n\r\n    if (offRight) {\r\n        offX = bounds.left + bounds.width - viewport.width;\r\n    }\r\n\r\n    const percentageX = roundPercentage(((bounds.width - offX) * 100) / (bounds.width || 1));\r\n    const percentageY = roundPercentage(((bounds.height - offY) * 100) / (bounds.height || 1));\r\n\r\n    return {\r\n        x: percentageX,\r\n        y: percentageY,\r\n        ratio: Math.min(percentageX, percentageY)\r\n    };\r\n};\r\n\r\n/**\r\n * @param {HTMLElement} element\r\n * @returns {Object}\r\n */\r\nexport const getElementViewportIntersection = element => {\r\n    if (isIntersectionObserverSupported) {\r\n        if (!('observer' in element)) {\r\n            element.observer = new IntersectionObserver(\r\n                entries =>\r\n                    entries.forEach(entry => {\r\n                        entry.target.DOMRect = entry.boundingClientRect;\r\n                        entry.target.intersection = entry.isIntersecting\r\n                            ? {\r\n                                  x: roundPercentage((entry.intersectionRect.width / entry.target.DOMRect.width) * 100),\r\n                                  y: roundPercentage((entry.intersectionRect.height / entry.target.DOMRect.height) * 100),\r\n                                  ratio: roundPercentage(entry.intersectionRatio * 100)\r\n                              }\r\n                            : {\r\n                                  x: 0,\r\n                                  y: 0,\r\n                                  ratio: 0\r\n                              };\r\n                    }),\r\n                {\r\n                    threshold: intersectionObserverThreshold\r\n                }\r\n            );\r\n\r\n            element.observer.observe(element);\r\n        }\r\n\r\n        if (!('intersection' in element) /* TODO: or not triggering intersetionobserver cb in a while ... */) {\r\n            element.DOMRect = element.getBoundingClientRect();\r\n            element.intersection = getBoundsViewportIntersection(element.DOMRect);\r\n        }\r\n\r\n        return element.intersection;\r\n    }\r\n\r\n    element.DOMRect = element.getBoundingClientRect();\r\n    element.intersection = getBoundsViewportIntersection(element.DOMRect);\r\n\r\n    return element.intersection;\r\n};\r\n\r\n/**\r\n * @param {NodeList|Array<HTMLElement>} elements\r\n * @param {('ratio'|'x'|'y')} mode\r\n * @returns {Array<HTMLElement>}\r\n */\r\nexport const getInViewportElements = (elements, mode = 'ratio', percentage = 0) => {\r\n    percentage = roundPercentage(percentage);\r\n    return [...elements].filter(percentage === 100 ? el => getElementViewportIntersection(el)[mode] >= percentage : el => getElementViewportIntersection(el)[mode] > percentage);\r\n};\r\n\r\n/**\r\n * @param {NodeList|Array<HTMLElement>} elements\r\n * @param {('ratio'|'x'|'y')} mode\r\n * @returns {Array<HTMLElement>}\r\n */\r\nexport const getFullyInViewportElements = (elements, mode = 'ratio') => getInViewportElements(elements, mode, 100);\r\n\r\n/**\r\n *\r\n * @param {NodeList|Array<HTMLElement>} elements\r\n * @param {('left top'|'left center'|'left bottom'|'right top'|'right center'|'right bottom'|'center top'|'center center'|'center bottom')} quadrant\r\n * @returns {Array<HTMLElement>}\r\n */\r\nexport const getMostInViewportElement = (elements, quadrant = 'center center') => {\r\n    elements = getInViewportElements(elements);\r\n    // TODO: https://codepen.io/memob0x/pen/bjKbNM\r\n    /*quadrant = quadrant.split(' ');\r\n    switch (quadrant) {\r\n        case 'center':\r\n            return getInViewportElements(elements, 'ratio').reduce((prev, curr) => (Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev));\r\n            break;\r\n    }*/\r\n};\r\n\r\n/**\r\n *\r\n * @param {NodeList|Array<HTMLElement>}  elements\r\n * @param {('x'|'y'|'both')} axis\r\n * @returns {Array<HTMLElement>}\r\n */\r\nexport const getOverlappingElements = (elements, mode = 'ratio') => {\r\n    elements = getInViewportElements(elements, mode);\r\n\r\n    let rects = [];\r\n    [...elements].forEach(element => {\r\n        if (element.intersection[mode] === 100) {\r\n            element.DOMRect = element.getBoundingClientRect();\r\n        }\r\n        rects.push(element.DOMRect);\r\n    });\r\n\r\n    let overlappingElements = [];\r\n    [...elements].forEach((element, i) => {\r\n        let rectA = rects[i];\r\n\r\n        for (let x in rects) {\r\n            // skips its own rects\r\n            if (parseInt(x) === i) {\r\n                continue;\r\n            }\r\n\r\n            const rectB = rects[x];\r\n            const overlappingX = rectA.right > rectB.left && rectA.left < rectB.right;\r\n            const overlappingY = rectA.bottom > rectB.top && rectA.top < rectB.bottom;\r\n            let overlapping = false;\r\n\r\n            switch (mode) {\r\n                case 'x':\r\n                    overlapping = overlappingX;\r\n                    break;\r\n                case 'y':\r\n                    overlapping = overlappingY;\r\n                    break;\r\n                case 'ratio':\r\n                    overlapping = overlappingX && overlappingY;\r\n                    break;\r\n            }\r\n\r\n            if (overlapping) {\r\n                overlappingElements.push(element);\r\n            }\r\n        }\r\n    });\r\n\r\n    return overlappingElements;\r\n};\r\n","import { stringStartsWith, stringContains } from './toolbox.utils.js';\r\n\r\nconst eventNamespaceParserSeparator = '__namespace__';\r\nlet privateEventsStorage = {};\r\n\r\nexport const CustomEvent =\r\n    window.CustomEvent ||\r\n    (() => {\r\n        const _polyfill = (event, params) => {\r\n            params = params || { bubbles: false, cancelable: false, detail: undefined };\r\n            const evt = document.createEvent('CustomEvent');\r\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\r\n            return evt;\r\n        };\r\n        _polyfill.prototype = window.Event.prototype;\r\n        return _polyfill;\r\n    })();\r\n\r\n/**\r\n * @param {HTMLElement} element\r\n * @param {string} events\r\n * @returns {undefined}\r\n */\r\nexport const detachEventListener = (element, events) => {\r\n    if (!element || typeof events !== 'string') {\r\n        return;\r\n    }\r\n\r\n    if (stringStartsWith(events, '.')) {\r\n        for (let key in privateEventsStorage) {\r\n            const eventNameWithNamespace = key.replace(eventNamespaceParserSeparator, '.');\r\n            if (stringContains(eventNameWithNamespace, events) && privateEventsStorage[key].element === element) {\r\n                detachEventListener(element, eventNameWithNamespace);\r\n            }\r\n        }\r\n    } else {\r\n        events = events.split('.');\r\n\r\n        const type = events[0],\r\n            namespace = events[1];\r\n\r\n        if (namespace) {\r\n            events = events.join(eventNamespaceParserSeparator);\r\n        }\r\n\r\n        if (events in privateEventsStorage) {\r\n            element.removeEventListener(type, privateEventsStorage[events].handler);\r\n            delete privateEventsStorage[events];\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * @param {HTMLElement} element\r\n * @param {string} events\r\n * @param {Function} handler\r\n * @param {boolean} once\r\n * @returns {undefined}\r\n */\r\n// TODO: Class EventListener .on .one .off .trigger jQuery-like...\r\nexport const attachEventListener = (element, events, handler, once) => {\r\n    if (!element || typeof events !== 'string' || typeof handler !== 'function') {\r\n        return;\r\n    }\r\n\r\n    events = events.split('.');\r\n\r\n    const type = events[0];\r\n    const namespace = events[1];\r\n\r\n    if (namespace) {\r\n        events = events.join(eventNamespaceParserSeparator);\r\n    }\r\n\r\n    privateEventsStorage[events] = { element: element, count: 0, once: false };\r\n\r\n    if (true === once) {\r\n        let _handler = handler;\r\n        handler = function(event) {\r\n            if (events in privateEventsStorage) {\r\n                privateEventsStorage[events].count++;\r\n                if (privateEventsStorage[events].once && privateEventsStorage[events].count > 1) {\r\n                    return;\r\n                }\r\n                _handler.call(this, event);\r\n            }\r\n            detachEventListener(element, events);\r\n        };\r\n    } else {\r\n        once = false;\r\n    }\r\n\r\n    privateEventsStorage[events] = {\r\n        ...privateEventsStorage[events],\r\n        ...{ handler: handler, once: once }\r\n    };\r\n\r\n    element.addEventListener(type, privateEventsStorage[events].handler, { once: once });\r\n};\r\n","import { isPromise } from './griddie.utils.js';\r\nimport { attachTimeout, detachTimeout } from './toolbox/src/toolbox.timers.js';\r\nimport { Viewport } from './toolbox/src/toolbox.viewport.js';\r\nimport { attachEventListener, detachEventListener } from './toolbox/src/toolbox.events.js';\r\n\r\nexport default class Griddie {\r\n    constructor(element, options) {\r\n        this._element = element;\r\n        this._items = [...this._element.children];\r\n        this._options = {};\r\n        this._viewport = new Viewport();\r\n\r\n        this._element.instance = this;\r\n\r\n        this.options = options;\r\n        this.layout();\r\n        attachEventListener(window, 'resize.griddie', () => this.layout());\r\n    }\r\n\r\n    set options(options) {\r\n        this._options = {\r\n            ...{\r\n                scaleXY: false, // TODO: single item exceptions ...\r\n                opacityTiming: 300,\r\n                transformTiming: 300,\r\n                masonry: false\r\n            },\r\n            ...options\r\n        };\r\n        this._options.transformTimingCSS = this.options.transformTiming / 1000;\r\n        this._options.opacityTimingCSS = this.options.opacityTiming / 1000;\r\n    }\r\n\r\n    get options() {\r\n        return this._options;\r\n    }\r\n\r\n    animate(layoutChanges = () => {}) {\r\n        if (!('instance' in this._element)) {\r\n            return;\r\n        }\r\n\r\n        const animation = new Promise((resolve, reject) => {\r\n            const callback = () => {\r\n                this.clearGridStyles();\r\n                this.clearItemsStyles();\r\n                this.layout();\r\n                this.storeGridData(1);\r\n                this.storeItemsData(1);\r\n                this.applyGridStyles(0);\r\n                this.applyItemsStyles(0);\r\n\r\n                requestAnimationFrame(() => {\r\n                    const transformTransition = 'transform ' + this._options.transformTimingCSS + 's ease';\r\n                    const widthHeightTransition = 'width ' + this._options.transformTimingCSS + 's ease, height ' + this._options.transformTimingCSS + 's ease';\r\n\r\n                    this._element.style.transition = widthHeightTransition + ', ' + transformTransition;\r\n\r\n                    [...this._items].filter(item => item.style.display !== 'none').forEach(item => {\r\n                        let transition = transformTransition;\r\n                        if (!this.options.scaleXY) {\r\n                            transition += ', ' + widthHeightTransition;\r\n                        }\r\n                        item.style.transition = transition;\r\n                    });\r\n\r\n                    requestAnimationFrame(() => {\r\n                        this.applyGridStyles(1);\r\n                        this.applyItemsStyles(1);\r\n                    });\r\n\r\n                    attachTimeout(\r\n                        this._element,\r\n                        () => {\r\n                            this.clearGridStyles();\r\n                            this.clearItemsStyles();\r\n                            resolve();\r\n                        },\r\n                        this.options.transformTiming,\r\n                        'transform'\r\n                    );\r\n                });\r\n            };\r\n\r\n            detachTimeout(this._element, 'transform');\r\n\r\n            this.clearGridStyles();\r\n            this.clearItemsStyles();\r\n            this.storeGridData(0);\r\n            this.storeItemsData(0);\r\n            this.applyGridStyles(0);\r\n            this.applyItemsStyles(0);\r\n\r\n            const changes = layoutChanges();\r\n\r\n            if (isPromise(changes)) {\r\n                changes.then(() => callback());\r\n            } else {\r\n                requestAnimationFrame(() => callback());\r\n            }\r\n        });\r\n\r\n        return animation;\r\n    }\r\n\r\n    filter(filter = '*') {\r\n        if (!('instance' in this._element)) {\r\n            return;\r\n        }\r\n\r\n        const matched = this._items.filter(x => x.matches(filter));\r\n        const unmatched = this._items.filter(x => !x.matches(filter));\r\n        const hiddenMatched = matched.filter(x => x.style.display === 'none');\r\n        const makeRoomBeforeFade = matched.length !== hiddenMatched.length;\r\n\r\n        const prepareFade = () => {\r\n            this._items.forEach(item => {\r\n                item.style.transition = 'opacity ' + this._options.opacityTimingCSS + 's ease';\r\n            });\r\n        };\r\n        const fade = () => {\r\n            matched.forEach(item => {\r\n                item.style.opacity = 1;\r\n            });\r\n\r\n            unmatched.forEach(item => {\r\n                item.style.opacity = 0;\r\n            });\r\n        };\r\n        const clearFade = () => {\r\n            this._items.forEach(item => {\r\n                item.style.transition = '';\r\n                item.style.opacity = '';\r\n            });\r\n\r\n            matched.forEach(item => {\r\n                item.style.display = '';\r\n            });\r\n\r\n            unmatched.forEach(item => {\r\n                item.style.display = 'none';\r\n            });\r\n        };\r\n\r\n        const animation = this.animate(() => {\r\n            detachTimeout(this._element, 'opacity');\r\n\r\n            const fadeAfterAnimation = new Promise((resolve, reject) => {\r\n                const onFadeEnd = () => {\r\n                    //this.storeGridData(0);\r\n                    this.storeItemsData(0);\r\n                    this.applyGridStyles(0);\r\n                    this.applyItemsStyles(0);\r\n                    resolve();\r\n                };\r\n\r\n                prepareFade();\r\n\r\n                if (hiddenMatched.length) {\r\n                    hiddenMatched.forEach(item => {\r\n                        item.style.opacity = 0;\r\n                    });\r\n                }\r\n\r\n                requestAnimationFrame(() => {\r\n                    if (hiddenMatched.length) {\r\n                        hiddenMatched.forEach(item => {\r\n                            item.style.display = '';\r\n                        });\r\n                    }\r\n\r\n                    if (hiddenMatched.length && makeRoomBeforeFade) {\r\n                        requestAnimationFrame(() => onFadeEnd());\r\n                    } else if (!hiddenMatched.length || (hiddenMatched.length && !makeRoomBeforeFade)) {\r\n                        requestAnimationFrame(() => {\r\n                            fade();\r\n\r\n                            attachTimeout(\r\n                                this._element,\r\n                                () => {\r\n                                    clearFade();\r\n\r\n                                    requestAnimationFrame(() => onFadeEnd());\r\n                                },\r\n                                this.options.opacityTiming,\r\n                                'opacity'\r\n                            );\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n\r\n            return fadeAfterAnimation;\r\n        });\r\n\r\n        animation.then(() => {\r\n            if (makeRoomBeforeFade) {\r\n                prepareFade();\r\n\r\n                requestAnimationFrame(() => {\r\n                    fade();\r\n\r\n                    clearTimeout(this._filterTimeout);\r\n\r\n                    this._filterTimeout = setTimeout(() => clearFade(), this.options.opacityTiming);\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    destroy() {\r\n        this.clearGridStyles();\r\n        this.clearItemsStyles();\r\n        this._items.forEach(item => {\r\n            item.style.gridRowEnd = ''; // TODO: possibly in clear methods?\r\n            item.style.display = ''; // TODO: possibly in clear methods?\r\n            delete item.rect;\r\n        });\r\n        delete this._element.rect;\r\n        detachTimeout(this._element, 'transform');\r\n        detachTimeout(this._element, 'opacity');\r\n        detachEventListener(window, 'resize.griddie');\r\n        delete this._element.instance;\r\n    }\r\n\r\n    refresh() {\r\n        if (!('instance' in this._element)) {\r\n            return;\r\n        }\r\n        // TODO: do it\r\n    }\r\n\r\n    // TODO: private\r\n    layout() {\r\n        if (!('instance' in this._element)) {\r\n            return;\r\n        }\r\n\r\n        this._element.style.position = 'relative';\r\n\r\n        const computed = window.getComputedStyle(this._element);\r\n        const display = computed.getPropertyValue('display');\r\n\r\n        if (this._options.masonry) {\r\n            if (computed.getPropertyValue('grid-template-columns') === 'none') {\r\n                this._element.style.gridTemplateColumns = 'repeat(auto-fill, minmax(250px, 1fr))';\r\n            }\r\n\r\n            if (display !== 'grid') {\r\n                this._element.style.display = 'grid';\r\n            }\r\n\r\n            let rowHeight = computed.getPropertyValue('grid-auto-rows');\r\n            if (rowHeight === 'auto') {\r\n                rowHeight = this._element.style.gridAutoRows = '20px';\r\n            }\r\n            rowHeight = parseInt(rowHeight);\r\n\r\n            if (computed.getPropertyValue('grid-column-gap') === 'normal') {\r\n                this._element.style.gridColumnGap = '0px';\r\n            }\r\n\r\n            let rowGap = computed.getPropertyValue('grid-row-gap');\r\n            if (rowGap === 'normal') {\r\n                rowGap = this._element.style.gridRowGap = '0px';\r\n            }\r\n            rowGap = parseInt(rowGap);\r\n\r\n            this._items.filter(item => item.style.display !== 'none').forEach(item => {\r\n                const rowSpan = Math.ceil(([...item.children][0].getBoundingClientRect().height + rowGap) / (rowHeight + rowGap));\r\n                item.style.gridRowEnd = 'span ' + rowSpan;\r\n            });\r\n        } else {\r\n            this._element.style.display = '';\r\n            this._element.style.gridTemplateColumns = '';\r\n            this._element.style.gridAutoRows = '';\r\n            this._element.style.gridColumnGap = '';\r\n            this._element.style.gridRowGap = '';\r\n            this._items.filter(item => item.style.display !== 'none').forEach(item => {\r\n                item.style.gridRowEnd = '';\r\n            });\r\n        }\r\n    }\r\n\r\n    // TODO: private\r\n    clearGridStyles() {\r\n        if (!('instance' in this._element)) {\r\n            return;\r\n        }\r\n\r\n        this._element.style.position = 'relative'; // ooooverkill\r\n        this._element.style.transform = '';\r\n        this._element.style.width = '';\r\n        this._element.style.height = '';\r\n        this._element.style.transition = '';\r\n        this._element.style.margin = '';\r\n    }\r\n\r\n    // TODO: private\r\n    clearItemsStyles() {\r\n        if (!('instance' in this._element)) {\r\n            return;\r\n        }\r\n\r\n        this._items.forEach(item => {\r\n            item.style.transform = '';\r\n            item.style.transformOrigin = '';\r\n            item.style.position = '';\r\n            item.style.transition = '';\r\n            item.style.width = '';\r\n            item.style.height = '';\r\n            item.style.margin = '';\r\n        });\r\n    }\r\n\r\n    // TODO: private\r\n    storeGridData(id = 0) {\r\n        if (!('instance' in this._element)) {\r\n            return;\r\n        }\r\n\r\n        this._viewport.calcScrollTop(); // TODO: optimize\r\n        this._viewport.calcScrollLeft(); // TODO: optimize\r\n\r\n        const gridRect = this._element.getBoundingClientRect();\r\n        const computed = window.getComputedStyle(this._element);\r\n        if (!('rect' in this._element)) {\r\n            this._element.rect = [];\r\n        }\r\n\r\n        this._element.rect[id] = {\r\n            width: gridRect.width,\r\n            height: gridRect.height,\r\n            top: gridRect.top + this._viewport.scrollTop,\r\n            left: gridRect.left + this._viewport.scrollLeft,\r\n            marginTop: parseInt(computed.getPropertyValue('margin-top')),\r\n            marginLeft: parseInt(computed.getPropertyValue('margin-left'))\r\n        };\r\n    }\r\n\r\n    // TODO: private\r\n    storeItemsData(id = 0) {\r\n        if (!('instance' in this._element)) {\r\n            return;\r\n        }\r\n\r\n        this._viewport.calcScrollTop(); // TODO: optimize\r\n        this._viewport.calcScrollLeft(); // TODO: optimize\r\n\r\n        this._items.filter(item => item.style.display !== 'none').forEach(item => {\r\n            if (!('rect' in item)) {\r\n                item.rect = [];\r\n            }\r\n\r\n            const itemRect = item.getBoundingClientRect();\r\n            item.rect[id] = {\r\n                width: itemRect.width,\r\n                height: itemRect.height,\r\n                top: itemRect.top + this._viewport.scrollTop - this._element.rect[id].top,\r\n                left: itemRect.left + this._viewport.scrollLeft - this._element.rect[id].left,\r\n                scaleX: 1,\r\n                scaleY: 1\r\n            };\r\n\r\n            item.rect[id].top = item.rect[id].top >= 0 ? item.rect[id].top : 0;\r\n            item.rect[id].left = item.rect[id].left >= 0 ? item.rect[id].left : 0;\r\n\r\n            if (id === 1) {\r\n                const scaleX = item.rect[0].width / itemRect.width;\r\n                const scaleY = item.rect[0].height / itemRect.height;\r\n\r\n                if (scaleX > 0) {\r\n                    item.rect[id].scaleX = 1 / scaleX;\r\n                }\r\n\r\n                if (scaleY > 0) {\r\n                    item.rect[id].scaleY = 1 / scaleY;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    // TODO: private\r\n    applyGridStyles(id = 0) {\r\n        if (!('instance' in this._element)) {\r\n            return;\r\n        }\r\n\r\n        this._element.style.margin = 0;\r\n        this._element.style.position = 'relative'; // overkill\r\n        this._element.style.transformOrigin = '0 0 0';\r\n        this._element.style.transform = 'translate3d(' + this._element.rect[id].marginLeft + 'px,' + this._element.rect[id].marginTop + 'px, 0px)';\r\n        this._element.style.width = this._element.rect[id].width + 'px';\r\n        this._element.style.height = this._element.rect[id].height + 'px';\r\n    }\r\n\r\n    // TODO: private\r\n    applyItemsStyles(id = 0) {\r\n        if (!('instance' in this._element)) {\r\n            return;\r\n        }\r\n\r\n        this._items.filter(item => item.style.display !== 'none').forEach(item => {\r\n            let transform = 'translate3d(' + item.rect[id].left + 'px,' + item.rect[id].top + 'px, 0px)';\r\n\r\n            if (this.options.scaleXY) {\r\n                transform += ' scale3d(' + item.rect[id].scaleX + ', ' + item.rect[id].scaleY + ', 1)';\r\n            }\r\n\r\n            if (!this.options.scaleXY || id === 0) {\r\n                item.style.width = item.rect[id].width + 'px';\r\n                item.style.height = item.rect[id].height + 'px';\r\n            }\r\n\r\n            item.style.margin = 0;\r\n            item.style.position = 'absolute';\r\n            item.style.transformOrigin = '0 0 0';\r\n            item.style.transform = transform;\r\n        });\r\n    }\r\n}\r\n"],"file":"griddie.min.js"}